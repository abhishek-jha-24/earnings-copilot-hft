"""
Explainability agent for generating investment memos.
Creates PDF reports with signal explanations, KPIs, and citations.
"""

import os
import json
from typing import Dict, Any, List, Optional
from datetime import datetime
from jinja2 import Template
import markdown
from io import BytesIO

try:
    from weasyprint import HTML, CSS
    WEASYPRINT_AVAILABLE = True
except (ImportError, OSError) as e:
    print(f"WeasyPrint not available - PDF generation will be disabled: {e}")
    WEASYPRINT_AVAILABLE = False
    HTML = None
    CSS = None

from agents.pathway_pipeline import pathway_service
from agents.benchmarks import benchmark_service


class ExplainabilityAgent:
    """Agent for generating explainable investment memos and reports."""
    
    def __init__(self):
        self.memo_template = self._create_memo_template()
    
    def _create_memo_template(self) -> Template:
        """Create Jinja2 template for investment memos."""
        template_str = """
# Investment Analysis: {{ ticker }} {{ period }}

**Generated:** {{ generated_at }}  
**Signal:** {{ signal.action }} ({{ "{:.0%}".format(signal.confidence) }} confidence)

## Executive Summary

Based on analysis of {{ ticker }}'s {{ period }} financial results, our recommendation is **{{ signal.action }}** with {{ "{:.0%}".format(signal.confidence) }} confidence.

{% if signal.reasons %}
**Key Factors:**
{% for reason in signal.reasons %}
- {{ reason }}
{% endfor %}
{% endif %}

## Financial Performance

{% if kpis %}
### Key Performance Indicators

| Metric | Current | Consensus | Surprise | YoY Change |
|--------|---------|-----------|----------|------------|
{% for kpi in kpis %}
| {{ kpi.metric|title }} | {{ kpi.value }} {{ kpi.unit }} | {{ kpi.consensus or "N/A" }} | {{ "{:.1%}".format(kpi.surprise) if kpi.surprise else "N/A" }} | {{ "{:.1%}".format(kpi.yoy_change) if kpi.yoy_change else "N/A" }} |
{% endfor %}
{% endif %}

{% if deltas %}
### Period-over-Period Changes

{% for delta in deltas %}
**{{ delta.metric|title }}:** {{ delta.current_value }} ({{ "{:+.1%}".format(delta.delta_pct) }} vs {{ delta.previous_period }})
{% endfor %}
{% endif %}

## Signal Analysis

{% if signal.metric_scores %}
### Metric Contributions

{% for metric, score in signal.metric_scores.items() %}
- **{{ metric|title }}:** {{ "{:+.2f}".format(score) }} impact
{% endfor %}

**Overall Score:** {{ "{:+.2f}".format(signal.overall_score) }}
{% endif %}

## Risk Assessment

{% if compliance_summary %}
### Compliance Status

- **Current Exposure:** {{ "{:.1%}".format(compliance_summary.current_exposure) }}
- **Active Rules:** {{ compliance_summary.active_rules }}
- **Status:** {{ compliance_summary.compliance_status|title }}

{% if compliance_summary.rules %}
#### Applicable Margin Requirements

{% for rule in compliance_summary.rules %}
- **{{ rule.rule_id }}:** Initial {{ "{:.1%}".format(rule.initial_margin) }}, Maintenance {{ "{:.1%}".format(rule.maintenance_margin) }}
{% endfor %}
{% endif %}
{% endif %}

## Data Sources & Citations

{% if signal.citations %}
{% for citation in signal.citations %}
### {{ citation.doc }}

**Page {{ citation.page }}, Table: {{ citation.table }}**

> {{ citation.text }}

{% endfor %}
{% endif %}

## Methodology

This analysis uses a quantitative approach combining:

1. **Consensus Surprise Analysis** - Comparing actual results to analyst expectations
2. **Trend Analysis** - Evaluating year-over-year and quarter-over-quarter changes  
3. **Margin Analysis** - Assessing profitability trends
4. **Risk Assessment** - Compliance and position size considerations

Signal confidence reflects data quality, metric alignment, and historical accuracy.

---

*This analysis is generated by an automated system and should be reviewed by qualified investment professionals before making investment decisions.*
"""
        return Template(template_str)
    
    async def generate_memo(self, ticker: str, period: str, 
                          include_citations: bool = True, 
                          include_compliance: bool = True) -> Dict[str, Any]:
        """
        Generate investment memo for a ticker and period.
        
        Args:
            ticker: Stock ticker symbol
            period: Financial period
            include_citations: Whether to include citations
            include_compliance: Whether to include compliance info
            
        Returns:
            Dictionary with markdown content and metadata
        """
        try:
            # Gather data for memo
            signal = await self._get_signal_data(ticker, period)
            kpis = await self._get_kpi_data(ticker, period)
            deltas = await pathway_service.get_deltas(ticker, period)
            
            compliance_summary = None
            if include_compliance:
                from agents.compliance_agent import compliance_agent
                compliance_summary = await compliance_agent.get_compliance_summary(ticker)
            
            # Filter citations if needed
            if not include_citations and signal:
                signal["citations"] = []
            
            # Generate markdown content
            memo_data = {
                "ticker": ticker,
                "period": period,
                "generated_at": datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
                "signal": signal or {},
                "kpis": kpis,
                "deltas": deltas,
                "compliance_summary": compliance_summary
            }
            
            markdown_content = self.memo_template.render(**memo_data)
            
            return {
                "ticker": ticker,
                "period": period,
                "markdown": markdown_content,
                "data": memo_data,
                "generated_at": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            print(f"Error generating memo for {ticker}: {e}")
            return {
                "ticker": ticker,
                "period": period,
                "error": str(e),
                "markdown": f"# Error\n\nFailed to generate memo: {e}",
                "generated_at": datetime.utcnow().isoformat()
            }
    
    async def generate_pdf(self, ticker: str, period: str, 
                          include_citations: bool = True,
                          include_compliance: bool = True) -> Optional[bytes]:
        """
        Generate PDF investment memo.
        
        Args:
            ticker: Stock ticker symbol
            period: Financial period
            include_citations: Whether to include citations
            include_compliance: Whether to include compliance info
            
        Returns:
            PDF bytes or None if generation failed
        """
        if not WEASYPRINT_AVAILABLE:
            print("PDF generation not available - WeasyPrint not installed")
            return None
        
        try:
            # Generate markdown memo
            memo = await self.generate_memo(ticker, period, include_citations, include_compliance)
            markdown_content = memo.get("markdown", "")
            
            if memo.get("error"):
                return None
            
            # Convert markdown to HTML
            html_content = markdown.markdown(markdown_content, extensions=['tables'])
            
            # Add CSS styling
            styled_html = self._add_pdf_styling(html_content)
            
            # Generate PDF
            html_doc = HTML(string=styled_html)
            pdf_bytes = html_doc.write_pdf()
            
            return pdf_bytes
            
        except Exception as e:
            print(f"Error generating PDF for {ticker}: {e}")
            return None
    
    def _add_pdf_styling(self, html_content: str) -> str:
        """Add CSS styling for PDF generation."""
        css_styles = """
        <style>
        body {
            font-family: 'Helvetica', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        
        h3 {
            color: #7f8c8d;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        blockquote {
            border-left: 4px solid #3498db;
            margin: 20px 0;
            padding-left: 20px;
            font-style: italic;
            color: #7f8c8d;
        }
        
        .signal-buy { color: #27ae60; font-weight: bold; }
        .signal-sell { color: #e74c3c; font-weight: bold; }
        .signal-hold { color: #f39c12; font-weight: bold; }
        
        @page {
            margin: 1in;
            @top-center {
                content: "Investment Analysis - Confidential";
                font-size: 10px;
                color: #7f8c8d;
            }
            @bottom-right {
                content: counter(page);
                font-size: 10px;
            }
        }
        </style>
        """
        
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Investment Analysis</title>
            {css_styles}
        </head>
        <body>
            {html_content}
        </body>
        </html>
        """
    
    async def _get_signal_data(self, ticker: str, period: str) -> Optional[Dict[str, Any]]:
        """Get signal data for memo."""
        try:
            from services.storage import get_signal
            signal_data = await get_signal(ticker)
            
            if signal_data and signal_data.get("period") == period:
                return signal_data
            
            # If no cached signal, generate one
            from agents.signal_agent import signal_agent
            return await signal_agent.decide(ticker, period)
            
        except Exception as e:
            print(f"Error getting signal data: {e}")
            return None
    
    async def _get_kpi_data(self, ticker: str, period: str) -> List[Dict[str, Any]]:
        """Get KPI data for memo."""
        try:
            latest_kpis = await pathway_service.get_latest_kpis(ticker)
            
            kpi_list = []
            for metric, kpi_data in latest_kpis.items():
                if kpi_data.get("period") == period:
                    # Enrich with consensus data
                    enriched = benchmark_service.enrich_kpi_with_consensus(kpi_data)
                    kpi_list.append(enriched)
            
            return kpi_list
            
        except Exception as e:
            print(f"Error getting KPI data: {e}")
            return []
    
    def create_signal_summary(self, signal: Dict[str, Any]) -> str:
        """Create a brief text summary of a signal."""
        if not signal:
            return "No signal available"
        
        action = signal.get("action", "HOLD")
        confidence = signal.get("confidence", 0)
        ticker = signal.get("ticker", "")
        
        summary = f"{action} {ticker} ({confidence:.0%} confidence)"
        
        reasons = signal.get("reasons", [])
        if reasons:
            summary += f": {reasons[0]}"
        
        return summary
    
    def format_kpi_change(self, current: float, previous: float, 
                         metric_type: str = "value") -> str:
        """Format KPI change for display."""
        if previous == 0:
            return "N/A"
        
        change = (current - previous) / previous
        
        if metric_type in ["margin", "ratio"]:
            # For ratios, show basis points
            bp_change = change * 10000
            return f"{bp_change:+.0f}bp"
        else:
            # For absolute values, show percentage
            return f"{change:+.1%}"


# Global explainability agent instance
explainability_agent = ExplainabilityAgent()
